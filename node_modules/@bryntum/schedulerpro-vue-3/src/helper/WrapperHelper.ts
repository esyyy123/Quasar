/**
 * Vue 3 widget helper
 */

import { type ComponentInternalInstance, nextTick } from 'vue';
import { StringHelper, Widget } from '@bryntum/schedulerpro';

interface RenderElement extends HTMLElement {
    vueKey: string;
}

export type Data = Record<string, unknown>;

type SuppressNew<T> = { [K in keyof T]: T[ K ] }

type AnyConstructor<
    Instance extends object = object,
    Static extends object = object
> = (new (...input: any[]) => Instance) & SuppressNew<Static>

type AnyWidget = AnyConstructor<any, any>;

type RenderData = {
    record: any,
    row: any,
    column: any,
    cellElement: RenderElement
}

export type WidgetData<T extends AnyWidget> = {
    instanceClass: T,
    instanceName: string
    isView?: boolean,
    dataStores?: object,
    projectStores?: boolean,
    configNames: string[]
    propertyConfigNames: string[]
    propertyNames: string[]
    eventNames: string[]
    featureNames?: string[]
}

export type WidgetConfig<T extends AnyWidget> = {
    me?: ComponentInternalInstance;
    props: Data;
    widgetData: WidgetData<T>,
    emit: (...args: any[]) => any
    element: HTMLDivElement;
    processCellContent?: Function;
    hasFrameworkRenderer?: Function;
    toRaw?: Function
}

export type BryntumConfig = Record<string, any> & {
    vueComponent?: Object,
    listeners: Record<string, Function>,
    features: {},
    processCellContent: Function,
    hasFrameworkRenderer: Function
};

export class WrapperHelper {

    /**
     * Development warning. Showed when environment is set to 'development'
     * @param {String} clsName vue component instance
     * @param {String} msg console message
     */
    static devWarning(clsName: string, msg: string) {
        // @ts-ignore
        if (window['bryntum'].isTestEnv || process.env.NODE_ENV === 'development') {
            console.warn(`Bryntum${clsName}Component development warning!\n${msg}\n` +
                'Please check Vue integration guide: https://bryntum.com/products/grid/docs/guide/Grid/integration/vue/guide'
            );
        }
    }

    static devWarningContainer(clsName: string, containerParam: string) {
        WrapperHelper.devWarning(clsName,
            `Using "${containerParam}" parameter for configuration is not recommended.\n` +
            'Widget is placed automatically inside it\'s container element.\n' +
            `Solution: remove "${containerParam}" parameter from configuration.`
        );
    }

    static devWarningConfigProp(clsName: string, prop: string) {
        WrapperHelper.devWarning(clsName,
            `Using "${prop}" parameter for configuration is not recommended.\n` +
            `Solution: Use separate parameter for each "${prop}" value to enable reactive updates of the API instance`
        );
    }

    static devWarningUpdateProp(clsName: string, prop: string) {
        WrapperHelper.devWarning(clsName,
            `"${prop}" is a static config option for component constructor only. No runtime changes are supported!`
        );
    }

    /**
     * Creates bryntum component config from vue component
     * @param {Object} context
     * @param {Object} context.me vue component instance
     * @param {Object} context.props reference to props
     * @param {Object} context.widgetData reference to data
     * @param {Function} context.emit reference to emit
     * @param {Object} context.element HTML element
     * @param {Function} context.processCellContent cell renderer method
     * @param {Function} context.hasFrameworkRenderer checks presence of vue renderer
     * @param {Function} context.toRaw Vue fn to unwrap reactive object
     * @returns {Object} config object
     */
    static createConfig<T extends AnyWidget>({
        me,
        props,
        widgetData,
        emit,
        element,
        processCellContent,
        hasFrameworkRenderer,
        toRaw
    }: WidgetConfig<T>) {
        const
            {
                instanceClass,
                instanceName
            }                   = widgetData,
            filter              = (arr: string[]) => arr.filter(prop => props[prop] !== undefined),
            configNames         = filter(widgetData.configNames || []),
            propertyConfigNames = filter(widgetData.propertyConfigNames || []),
            propertyNames       = filter(widgetData.propertyNames || []),
            featureNames        = filter(widgetData.featureNames || []),
            bryntumConfig       = {
                vueComponent : me,
                listeners    : {},
                features     : {},
                processCellContent,
                hasFrameworkRenderer
            } as BryntumConfig;

        // Setup events listeners
        widgetData.eventNames.forEach(eventName => {
            const onFunctionName = `on${StringHelper.capitalize(eventName)}`;
            // Vue prefixes DOM events with on, for example click becomes `onClick`, which
            // is same as our on-Function. Therefore, the DOM events' handlers are called twice.
            // This prevents firing the event if we already have on-created by Vue.
            if (!props[onFunctionName]) {
                bryntumConfig.listeners[eventName] = (params: any) => emit(eventName, params);
            }
        });

        // Assign configs. Skip properties
        [
            ...configNames,
            ...propertyConfigNames,
            ...featureNames
        ].forEach(prop => {
            WrapperHelper.applyPropValue(bryntumConfig, prop, props[prop], true, toRaw);
            if (['features', 'config'].includes(prop)) {
                WrapperHelper.devWarningConfigProp(instanceClass.$name, prop);
            }
        });

        // Add vue wrapper class name
        bryntumConfig.cls = (bryntumConfig.cls || '') + ` b-vue-${instanceClass.$name.toLowerCase()}-container`;

        // Prepare watch arrays
        widgetData.configNames   = configNames;
        widgetData.propertyNames = [
            ...configNames,
            ...propertyNames,
            ...propertyConfigNames,
            ...featureNames
        ];

        // Cleanup unused instance arrays
        widgetData.eventNames          = [];
        widgetData.propertyConfigNames = [];
        widgetData.featureNames        = [];

        // If component has no container specified in config then use adopt to Wrapper's element
        const
            containerParam = [
                'adopt',
                'appendTo',
                'insertAfter',
                'insertBefore'
            ].find((prop: string) => bryntumConfig[prop]);

        if (!containerParam) {
            if (instanceName === 'Button') {
                // Button should always be <a> or <button> inside owner element
                bryntumConfig.appendTo = element;
            }
            else {
                bryntumConfig.adopt = element;
            }
        }
        else {
            WrapperHelper.devWarningContainer(instanceClass.$name, containerParam);
        }
        return bryntumConfig;
    }

    /**
     * Setup store events relay
     * @param {Object} data reference to data
     * @param {Object} instance bryntum widget instance
     */
    static relayStores(data: any, instance: any) {
        const { dataStores, projectStores } = data;

        if (dataStores) {
            Object.keys(dataStores).forEach(storeName => {
                const store = projectStores ? instance.project[storeName] : instance[storeName];
                if (store) {
                    // Set `syncDataOnLoad` to `true` by default
                    // TODO: remove when https://github.com/bryntum/support/issues/2764 is done
                    store.syncDataOnLoad = store.syncDataOnLoad == null ? true : store.syncDataOnLoad;
                    // Vue-3 fails to compile nullish coalescing https://github.com/bryntum/support/issues/2872
                    // store.syncDataOnLoad = store.syncDataOnLoad ?? true;

                    // Makes relaying store events configurable but off by default
                    if (instance && instance.relayStoreEvents) {
                        store.relayAll(instance, dataStores[storeName]);
                    }
                }
            });
            delete data.dataStores;
        }
    }

    /**
     * Creates bryntum Widget from vue component
     * @param {Object} config
     * @param {Object} config.me vue component instance
     * @param {Object} config.props reference to props
     * @param {Object} config.widgetData reference to data
     * @param {Function} config.emit reference to emit
     * @param {Object} config.element HTML element
     * @param {Function} config.processCellContent cell renderer method
     * @param {Function} config.hasFrameworkRenderer check the presence of vue renderer
     * @param {Function} config.toRaw Vue fn to unwrap reactive object
     * @returns {Object} widget object
     */
    static createWidget<T extends AnyWidget>(config: WidgetConfig<T>): InstanceType<T> {
        const
            { instanceClass } = config.widgetData,
            cfg               = WrapperHelper.createConfig(config);
        return (instanceClass.$name === 'Widget' ? Widget.create(cfg) : new instanceClass(cfg)) as InstanceType<T>;
    }

    /**
     * Applies property value to Bryntum config or instance.
     * @param {Object} configOrInstance target object
     * @param {String} prop property name
     * @param {Object} value value
     * @param {Boolean} [isConfig] config setting mode
     * @param {Function} [toRaw] Vue fn to unwrap reactive object
     */
    static applyPropValue(configOrInstance: any, prop: string, value: any, isConfig = true, toRaw?: Function) {

        if (prop === 'project') {
            // Allow use ProjectModel component as project
            if (value && typeof value === 'object') {
                configOrInstance[prop] = value.instance ? value.instance.value || value.instance : value;
            }
        }
        else if (prop === 'features' && typeof value === 'object') {
            Object.keys(value).forEach(key => WrapperHelper.applyPropValue(configOrInstance, `${key}Feature`, value[key], isConfig, toRaw));
        }
        else if (prop === 'config' && typeof value === 'object') {
            Object.keys(value).forEach(key => WrapperHelper.applyPropValue(configOrInstance, key, value[key], isConfig, toRaw));
        }
        else if (prop === 'columns' && !isConfig) {
            configOrInstance['columns'].data = value;
        }
        else if (prop.endsWith('Feature')) {
            const
                features    = configOrInstance['features'],
                featureName = prop.replace('Feature', '');
            if (isConfig) {
                features[featureName] = value;
            }
            else {
                const feature = features[featureName];
                if (feature) {
                    feature.setConfig(value);
                }
            }
        }
        else {
            configOrInstance[prop] = toRaw ? toRaw(value) : value;
        }
    }

    /**
     * Creates watches for vue component properties
     * @param {Object} me vue component instance
     * @param {Object} instance bryntum widget instance
     * @param {Object} props reference to props
     * @param {Object} data reference to data
     * @param {Function} watcher watch method reference (Accepts: prop and newValue)
     */
    static watchProps<T extends AnyWidget>(
        instance: InstanceType<T>,
        data: WidgetData<T>,
        watcher: (prop: string, callback: (value: any) => void) => void) {
        const
            {
                configNames,
                propertyNames,
                instanceClass
            } = data;

        propertyNames.forEach(prop => watcher(prop, newValue => {
            const value = Array.isArray(newValue) ? newValue.slice() : newValue;
            WrapperHelper.applyPropValue(instance, prop, value, false);

            // Check if property is a config and notify
            if (configNames.includes(prop)) {
                WrapperHelper.devWarningUpdateProp(instanceClass.$name, prop);
            }
        }));

        // Cleanup unused instance arrays
        data.configNames   = [];
        data.propertyNames = [];
    }

    /**
     * Cell renderer method
     * @param {Object} context
     * @param {RenderData} context.rendererData
     * @param {*} context.rendererHtml
     * @returns {Boolean}
     */
    static processCellContent({ rendererData, rendererHtml }: { rendererData: RenderData, rendererHtml: any }) {
        const { record, column, cellElement, row } = rendererData;

        // Only run for cells with vue renderers
        if (column.data.vue && column.data.renderer) {
            const
                // `this` is a caller component
                { vueComponent }                      = this as any,
                // `teleports` is javascript Map object
                { teleports : { value : teleports } } = vueComponent.provides,
                key                                   = `${column.id}-${record.id}`,
                renderElement                         = column.tree
                    ? cellElement.querySelector('.b-tree-cell-value')
                    : cellElement;

            // If the cell already has a teleport, release it
            if (cellElement.vueKey) {
                teleports.delete(cellElement.vueKey);
            }

            const
                bind   = { ...rendererHtml },
                { is } = bind;

            delete bind.is;

            // Create new teleport
            nextTick(() => {
                // Only teleport if the row is still used for the same record. Since this happens async, we might have
                // scrolled over the entire block of rows since the render
                if (row.id === record.id) {
                    teleports.set(key, {
                        bind,
                        key,
                        is,
                        to         : renderElement,
                        generation : record.generation
                    });
                }
            });

            // Link cell to the teleport, to be able to release it above
            cellElement.vueKey = key;
        }
    }

    /**
     *
     * @param {Object} context
     * @param {*} context.cellContent Content to be rendered in cell (set by renderer)
     * @param {*} context.column Column being rendered
     * @returns {Boolean} `true` if there is a Vue Renderer in this cell, `false` otherwise
     */
    static hasFrameworkRenderer({ cellContent, column }: { cellContent: any, column: any }) {
        return cellContent && typeof cellContent === 'object' && column?.data.vue;
    }

}
