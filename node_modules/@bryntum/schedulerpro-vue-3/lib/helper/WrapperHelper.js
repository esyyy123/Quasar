import { nextTick as h } from "vue";
import { StringHelper as b, Widget as E } from "@bryntum/schedulerpro";
class a {
  /**
   * Development warning. Showed when environment is set to 'development'
   * @param {String} clsName vue component instance
   * @param {String} msg console message
   */
  static devWarning(n, t) {
    (window.bryntum.isTestEnv || process.env.NODE_ENV === "development") && console.warn(
      `Bryntum${n}Component development warning!
${t}
Please check Vue integration guide: https://bryntum.com/products/grid/docs/guide/Grid/integration/vue/guide`
    );
  }
  static devWarningContainer(n, t) {
    a.devWarning(
      n,
      `Using "${t}" parameter for configuration is not recommended.
Widget is placed automatically inside it's container element.
Solution: remove "${t}" parameter from configuration.`
    );
  }
  static devWarningConfigProp(n, t) {
    a.devWarning(
      n,
      `Using "${t}" parameter for configuration is not recommended.
Solution: Use separate parameter for each "${t}" value to enable reactive updates of the API instance`
    );
  }
  static devWarningUpdateProp(n, t) {
    a.devWarning(
      n,
      `"${t}" is a static config option for component constructor only. No runtime changes are supported!`
    );
  }
  /**
   * Creates bryntum component config from vue component
   * @param {Object} context
   * @param {Object} context.me vue component instance
   * @param {Object} context.props reference to props
   * @param {Object} context.widgetData reference to data
   * @param {Function} context.emit reference to emit
   * @param {Object} context.element HTML element
   * @param {Function} context.processCellContent cell renderer method
   * @param {Function} context.hasFrameworkRenderer checks presence of vue renderer
   * @param {Function} context.toRaw Vue fn to unwrap reactive object
   * @returns {Object} config object
   */
  static createConfig({
    me: n,
    props: t,
    widgetData: e,
    emit: i,
    element: s,
    processCellContent: o,
    hasFrameworkRenderer: c,
    toRaw: f
  }) {
    const {
      instanceClass: d,
      instanceName: y
    } = e, m = (r) => r.filter((g) => t[g] !== void 0), l = m(e.configNames || []), N = m(e.propertyConfigNames || []), $ = m(e.propertyNames || []), p = m(e.featureNames || []), u = {
      vueComponent: n,
      listeners: {},
      features: {},
      processCellContent: o,
      hasFrameworkRenderer: c
    };
    e.eventNames.forEach((r) => {
      const g = `on${b.capitalize(r)}`;
      t[g] || (u.listeners[r] = (C) => i(r, C));
    }), [
      ...l,
      ...N,
      ...p
    ].forEach((r) => {
      a.applyPropValue(u, r, t[r], !0, f), ["features", "config"].includes(r) && a.devWarningConfigProp(d.$name, r);
    }), u.cls = (u.cls || "") + ` b-vue-${d.$name.toLowerCase()}-container`, e.configNames = l, e.propertyNames = [
      ...l,
      ...$,
      ...N,
      ...p
    ], e.eventNames = [], e.propertyConfigNames = [], e.featureNames = [];
    const v = [
      "adopt",
      "appendTo",
      "insertAfter",
      "insertBefore"
    ].find((r) => u[r]);
    return v ? a.devWarningContainer(d.$name, v) : y === "Button" ? u.appendTo = s : u.adopt = s, u;
  }
  /**
   * Setup store events relay
   * @param {Object} data reference to data
   * @param {Object} instance bryntum widget instance
   */
  static relayStores(n, t) {
    const { dataStores: e, projectStores: i } = n;
    e && (Object.keys(e).forEach((s) => {
      const o = i ? t.project[s] : t[s];
      o && (o.syncDataOnLoad = o.syncDataOnLoad == null ? !0 : o.syncDataOnLoad, t && t.relayStoreEvents && o.relayAll(t, e[s]));
    }), delete n.dataStores);
  }
  /**
   * Creates bryntum Widget from vue component
   * @param {Object} config
   * @param {Object} config.me vue component instance
   * @param {Object} config.props reference to props
   * @param {Object} config.widgetData reference to data
   * @param {Function} config.emit reference to emit
   * @param {Object} config.element HTML element
   * @param {Function} config.processCellContent cell renderer method
   * @param {Function} config.hasFrameworkRenderer check the presence of vue renderer
   * @param {Function} config.toRaw Vue fn to unwrap reactive object
   * @returns {Object} widget object
   */
  static createWidget(n) {
    const { instanceClass: t } = n.widgetData, e = a.createConfig(n);
    return t.$name === "Widget" ? E.create(e) : new t(e);
  }
  /**
   * Applies property value to Bryntum config or instance.
   * @param {Object} configOrInstance target object
   * @param {String} prop property name
   * @param {Object} value value
   * @param {Boolean} [isConfig] config setting mode
   * @param {Function} [toRaw] Vue fn to unwrap reactive object
   */
  static applyPropValue(n, t, e, i = !0, s) {
    if (t === "project")
      e && typeof e == "object" && (n[t] = e.instance ? e.instance.value || e.instance : e);
    else if (t === "features" && typeof e == "object")
      Object.keys(e).forEach((o) => a.applyPropValue(n, `${o}Feature`, e[o], i, s));
    else if (t === "config" && typeof e == "object")
      Object.keys(e).forEach((o) => a.applyPropValue(n, o, e[o], i, s));
    else if (t === "columns" && !i)
      n.columns.data = e;
    else if (t.endsWith("Feature")) {
      const o = n.features, c = t.replace("Feature", "");
      if (i)
        o[c] = e;
      else {
        const f = o[c];
        f && f.setConfig(e);
      }
    } else
      n[t] = s ? s(e) : e;
  }
  /**
   * Creates watches for vue component properties
   * @param {Object} me vue component instance
   * @param {Object} instance bryntum widget instance
   * @param {Object} props reference to props
   * @param {Object} data reference to data
   * @param {Function} watcher watch method reference (Accepts: prop and newValue)
   */
  static watchProps(n, t, e) {
    const {
      configNames: i,
      propertyNames: s,
      instanceClass: o
    } = t;
    s.forEach((c) => e(c, (f) => {
      const d = Array.isArray(f) ? f.slice() : f;
      a.applyPropValue(n, c, d, !1), i.includes(c) && a.devWarningUpdateProp(o.$name, c);
    })), t.configNames = [], t.propertyNames = [];
  }
  /**
   * Cell renderer method
   * @param {Object} context
   * @param {RenderData} context.rendererData
   * @param {*} context.rendererHtml
   * @returns {Boolean}
   */
  static processCellContent({ rendererData: n, rendererHtml: t }) {
    const { record: e, column: i, cellElement: s, row: o } = n;
    if (i.data.vue && i.data.renderer) {
      const { vueComponent: c } = this, { teleports: { value: f } } = c.provides, d = `${i.id}-${e.id}`, y = i.tree ? s.querySelector(".b-tree-cell-value") : s;
      s.vueKey && f.delete(s.vueKey);
      const m = { ...t }, { is: l } = m;
      delete m.is, h(() => {
        o.id === e.id && f.set(d, {
          bind: m,
          key: d,
          is: l,
          to: y,
          generation: e.generation
        });
      }), s.vueKey = d;
    }
  }
  /**
   *
   * @param {Object} context
   * @param {*} context.cellContent Content to be rendered in cell (set by renderer)
   * @param {*} context.column Column being rendered
   * @returns {Boolean} `true` if there is a Vue Renderer in this cell, `false` otherwise
   */
  static hasFrameworkRenderer({ cellContent: n, column: t }) {
    return n && typeof n == "object" && (t == null ? void 0 : t.data.vue);
  }
}
export {
  a as WrapperHelper
};
//# sourceMappingURL=WrapperHelper.js.map
