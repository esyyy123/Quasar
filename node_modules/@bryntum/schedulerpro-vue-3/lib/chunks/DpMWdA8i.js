import { defineComponent as S, ref as r, provide as C, onMounted as g, getCurrentInstance as h, toRaw as f, onBeforeUnmount as R, openBlock as D, createElementBlock as M, watch as v } from "vue";
import { ProjectModel as P } from "@bryntum/schedulerpro";
import { WrapperHelper as l } from "../helper/WrapperHelper.js";
const k = /* @__PURE__ */ S({
  __name: "BryntumSchedulerProProjectModel",
  props: {
    addConstraintOnDateSet: {},
    adjustDurationToDST: {},
    assignmentModelClass: {},
    assignments: {},
    assignmentsData: {},
    assignmentStore: {},
    assignmentStoreClass: {},
    autoCalculatePercentDoneForParentTasks: {},
    autoLoad: {},
    autoMergeAdjacentSegments: {},
    autoSync: {},
    autoSyncTimeout: {},
    bubbleEvents: {},
    calendar: {},
    calendarManagerStore: {},
    calendarManagerStoreClass: {},
    calendarModelClass: {},
    calendars: {},
    calendarsData: {},
    callOnFunctions: {},
    children: {},
    crudStores: {},
    daysPerMonth: {},
    daysPerWeek: {},
    delayCalculation: {},
    dependencies: {},
    dependenciesCalendar: {},
    dependenciesData: {},
    dependencyModelClass: {},
    dependencyStore: {},
    dependencyStoreClass: {},
    enableProgressNotifications: {},
    encoder: {},
    eventModelClass: {},
    events: {},
    eventsData: {},
    eventStore: {},
    eventStoreClass: {},
    expanded: {},
    forceSync: {},
    hoursPerDay: {},
    id: {},
    ignoreRemoteChangesInSTM: {},
    includeChildrenInRemoveRequest: {},
    json: {},
    lazyLoad: {},
    listeners: {},
    loadUrl: {},
    maxCalendarRange: {},
    orderedParentIndex: {},
    parentId: {},
    parentIndex: {},
    phantomIdField: {},
    phantomParentIdField: {},
    readOnly: {},
    remoteChildCount: {},
    resetIdsBeforeSync: {},
    resetUndoRedoQueuesAfterLoad: {},
    resourceAllocationInfoClass: {},
    resourceModelClass: {},
    resources: {},
    resourcesData: {},
    resourceStore: {},
    resourceStoreClass: {},
    resourceTimeRanges: {},
    resourceTimeRangesData: {},
    resourceTimeRangeStore: {},
    resourceTimeRangeStoreClass: {},
    shouldSyncDataOnLoad: { type: Function },
    silenceInitialCommit: {},
    skipNonWorkingTimeInDurationWhenSchedulingManually: {},
    skipNonWorkingTimeWhenSchedulingManually: {},
    skipSuccessProperty: {},
    stm: {},
    storeIdProperty: {},
    supportShortSyncResponse: {},
    syncApplySequence: {},
    syncUrl: {},
    taskStore: {},
    timeRanges: {},
    timeRangesData: {},
    timeRangeStore: {},
    timeRangeStoreClass: {},
    timeZone: {},
    toJSONResultFormat: {},
    trackProjectModelChanges: {},
    trackResponseType: {},
    transport: {},
    useRawData: {},
    validateResponse: {},
    writeAllFields: {}
  },
  emits: ["beforeDestroy", "beforeLoad", "beforeLoadApply", "beforeResponseApply", "beforeSend", "beforeSync", "beforeSyncApply", "catchAll", "change", "cycle", "dataReady", "destroy", "emptyCalendar", "hasChanges", "load", "loadCanceled", "loadFail", "noChanges", "progress", "requestDone", "requestFail", "revisionNotification", "schedulingConflict", "sync", "syncCanceled", "syncDelayed", "syncFail"],
  setup(d, { expose: c, emit: i }) {
    const u = d, p = i, s = {
      instanceClass: P,
      instanceName: "ProjectModel",
      configNames: [
        "adjustDurationToDST",
        "assignmentModelClass",
        "assignmentsData",
        "assignmentStoreClass",
        "autoLoad",
        "autoSync",
        "autoSyncTimeout",
        "bubbleEvents",
        "calendarManagerStoreClass",
        "calendarModelClass",
        "calendarsData",
        "callOnFunctions",
        "children",
        "delayCalculation",
        "dependenciesData",
        "dependencyModelClass",
        "dependencyStoreClass",
        "encoder",
        "eventModelClass",
        "eventsData",
        "eventStoreClass",
        "expanded",
        "includeChildrenInRemoveRequest",
        "listeners",
        "maxCalendarRange",
        "orderedParentIndex",
        "parentId",
        "parentIndex",
        "phantomIdField",
        "phantomParentIdField",
        "resetIdsBeforeSync",
        "resetUndoRedoQueuesAfterLoad",
        "resourceAllocationInfoClass",
        "resourceModelClass",
        "resourcesData",
        "resourceStoreClass",
        "resourceTimeRangesData",
        "resourceTimeRangeStoreClass",
        "silenceInitialCommit",
        "skipSuccessProperty",
        "storeIdProperty",
        "supportShortSyncResponse",
        "taskStore",
        "timeRangesData",
        "timeRangeStoreClass",
        "toJSONResultFormat",
        "trackResponseType",
        "transport",
        "useRawData",
        "validateResponse",
        "writeAllFields"
      ],
      propertyConfigNames: [
        "addConstraintOnDateSet",
        "assignments",
        "assignmentStore",
        "autoCalculatePercentDoneForParentTasks",
        "autoMergeAdjacentSegments",
        "calendar",
        "calendarManagerStore",
        "calendars",
        "crudStores",
        "daysPerMonth",
        "daysPerWeek",
        "dependencies",
        "dependenciesCalendar",
        "dependencyStore",
        "enableProgressNotifications",
        "events",
        "eventStore",
        "forceSync",
        "hoursPerDay",
        "id",
        "ignoreRemoteChangesInSTM",
        "json",
        "lazyLoad",
        "loadUrl",
        "onBeforeDestroy",
        "onBeforeLoad",
        "onBeforeLoadApply",
        "onBeforeResponseApply",
        "onBeforeSend",
        "onBeforeSync",
        "onBeforeSyncApply",
        "onCatchAll",
        "onChange",
        "onCycle",
        "onDataReady",
        "onDestroy",
        "onEmptyCalendar",
        "onHasChanges",
        "onLoad",
        "onLoadCanceled",
        "onLoadFail",
        "onNoChanges",
        "onProgress",
        "onRequestDone",
        "onRequestFail",
        "onRevisionNotification",
        "onSchedulingConflict",
        "onSync",
        "onSyncCanceled",
        "onSyncDelayed",
        "onSyncFail",
        "readOnly",
        "remoteChildCount",
        "resources",
        "resourceStore",
        "resourceTimeRanges",
        "resourceTimeRangeStore",
        "shouldSyncDataOnLoad",
        "skipNonWorkingTimeInDurationWhenSchedulingManually",
        "skipNonWorkingTimeWhenSchedulingManually",
        "stm",
        "syncApplySequence",
        "syncUrl",
        "timeRanges",
        "timeRangeStore",
        "timeZone",
        "trackProjectModelChanges"
      ],
      propertyNames: [
        "allChildren",
        "descendantCount",
        "hasGeneratedId",
        "inlineData",
        "internalId",
        "isCommitting",
        "isCreating",
        "isValid",
        "previousSiblingsTotalCount",
        "visibleDescendantCount"
      ],
      eventNames: [
        "beforeDestroy",
        "beforeLoad",
        "beforeLoadApply",
        "beforeResponseApply",
        "beforeSend",
        "beforeSync",
        "beforeSyncApply",
        "catchAll",
        "change",
        "cycle",
        "dataReady",
        "destroy",
        "emptyCalendar",
        "hasChanges",
        "load",
        "loadCanceled",
        "loadFail",
        "noChanges",
        "progress",
        "requestDone",
        "requestFail",
        "revisionNotification",
        "schedulingConflict",
        "sync",
        "syncCanceled",
        "syncDelayed",
        "syncFail"
      ]
    }, a = {}, o = r(), t = r(/* @__PURE__ */ new Map());
    return C("teleports", t), g(() => {
      const e = h();
      a.value = l.createWidget({
        me: e,
        props: u,
        emit: p,
        widgetData: s,
        element: o.value,
        toRaw: f
      });
      const n = (y, m) => v(() => e.props[y], m);
      l.watchProps(a.value, s, n);
    }), R(() => {
      var e, n;
      (n = (e = a.value) == null ? void 0 : e.destroy) == null || n.call(e);
    }), c({
      instance: a,
      refElement: o,
      teleports: t
    }), (e, n) => (D(), M("div", {
      ref_key: "refElement",
      ref: o
    }, null, 512));
  }
});
export {
  k as _
};
//# sourceMappingURL=DpMWdA8i.js.map
